import { ReduxModule } from 'react-pages'

import UserData from '../UserData/UserData'

const redux = new ReduxModule('THREAD_TRACKER')

export const getTrackedThreads = redux.simpleAction(
	(state) => ({
		...state,
		trackedThreads: _getTrackedThreads()
	})
)

// Using `.action()` instead of `.simpleAction()` here
// only to listen to the "success" event in `./redux/thread.js`.
export const trackThread = redux.action(
	'TRACK_THREAD',
	(thread) => async () => {
		// Just in case the thread both doesn't have a title
		// and a title wasn't autogenerated for some reason
		// (perhaps missing `messages` for "Picture", etc).
		if (!thread.title) {
			thread.title = `#${thread.id}`
		}
		// Using a timestamp instead of a `Date` because of
		// serialization/deserialization.
		thread.addedAt = Date.now()
		UserData.addTrackedThreadsList(thread)
		// Sort tracked threads.
		UserData.setTrackedThreadsList(UserData.getTrackedThreadsList().sort(sortTrackedThreads))
		return {
			// Returning `thread` here only to acess it in a listener
			// in `./redux/thread.js`.
			thread,
			trackedThreads: _getTrackedThreads()
		}
	},
	(state, { thread, trackedThreads }) => ({
		...state,
		trackedThreads
	})
)

// Using `.action()` instead of `.simpleAction()` here
// only to listen to the "success" event in `./redux/thread.js`.
export const untrackThread = redux.action(
	'UNTRACK_THREAD',
	(thread) => async () => {
		UserData.removeTrackedThreadsList(thread)
		return {
			// Returning `thread` here only to acess it in a listener
			// in `./redux/thread.js`.
			thread,
			trackedThreads: _getTrackedThreads()
		}
	},
	(state, { thread, trackedThreads }) => ({
		...state,
		trackedThreads
	})
)

redux.on('CHAN', 'GET_THREADS', (state, { boardId, threads }) => {
	// Clear expired threads from user data.
	UserData.updateThreads(boardId, threads)
	return {
	  ...state,
		trackedThreads: _getTrackedThreads()
	}
})

export const threadExpired = redux.simpleAction(
	(state, { boardId, threadId }) => {
		UserData.onThreadExpired(boardId, threadId)
		return {
			...state,
			trackedThreads: _getTrackedThreads()
		}
	}
)

export default redux.reducer({
	trackedThreads: typeof window === 'undefined' ? [] : _getTrackedThreads()
})

function _getTrackedThreads() {
	return UserData.getTrackedThreadsList()
}

// Sorts tracked threads in order:
// * Threads with new replies. Own threads first. More replies first.
// * Threads with new comments. Own threads first. More comments first.
// * Threads without new comments. Own threads first. Latest added first.
// * Expired threads. Own threads first. Latest added first.
function sortTrackedThreads(a, b) {
	// Expired threads go last.
	if (a.expired && b.expired) {
		// Own threads first.
		if (a.own && !b.own) {
			return -1
		} else if (!a.own && b.own) {
			return 1
		}
		// Later added ones first.
		return b.addedAt - a.addedAt
	} else if (a.expired && !b.expired) {
		return 1
	} else if (!a.expired && b.expired) {
		return -1
	}
	// Threads without new comments go before expired threads.
	if (!a.newCommentsCount && !b.newCommentsCount) {
		// Own threads first.
		if (a.own && !b.own) {
			return -1
		} else if (!a.own && b.own) {
			return 1
		}
		// Later added ones first.
		return b.addedAt - a.addedAt
	} else if (a.newCommentsCount && !b.newCommentsCount) {
		return -1
	} else if (!a.newCommentsCount && b.newCommentsCount) {
		return 1
	}
	// Threads with new replies first.
	if (a.newRepliesCount && b.newRepliesCount) {
		// Own threads first.
		if (a.own && !b.own) {
			return -1
		} else if (!a.own && b.own) {
			return 1
		}
		// More new replies first.
		if (a.newRepliesCount === b.newRepliesCount) {
			// More new comments first.
			return b.newCommentsCount - a.newCommentsCount
		}
		return b.newRepliesCount - a.newRepliesCount
	} else if (a.newRepliesCount && !b.newRepliesCount) {
		return -1
	} else if (!a.newRepliesCount && b.newRepliesCount) {
		return 1
	}
	// Threads with new comments left.
	// Own threads first.
	if (a.own && !b.own) {
		return -1
	} else if (!a.own && b.own) {
		return 1
	}
	// More new comments first.
	return b.newCommentsCount - a.newCommentsCount
}