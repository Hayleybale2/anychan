import Chan from './Chan'
import setThreadInfo from './utility/setThreadInfo'
import createByIdIndex from '../utility/createByIdIndex'
import getMessages from './utility/getMessages'
import configuration from '../configuration'
import UserData from '../UserData/UserData'

import {
	generateQuotes,
	setInReplyToQuotes,
	generatePreview,
	generateThreadTitle,
	hasTextContentExceptPostLinks
} from 'imageboard'

import getPostText from 'social-components/commonjs/utility/post/getPostText'
import trimText from 'social-components/commonjs/utility/post/trimText'
import { canGeneratePostQuoteIgnoringNestedPostQuotes } from 'social-components/commonjs/utility/post/generatePostQuote'

export default async function getThread({
	boardId,
	threadId,
	censoredWords,
	messages,
	http
}) {
	const chan = Chan({ censoredWords, messages, http })
	const thread = await chan.getThread({
		boardId,
		threadId
	}, {
		// The parser parses thread comments up to 4x faster without parsing their content.
		// Example: when parsing comments content — 650 ms, when not parsing comments content — 200 ms.
		parseContent: false
	})
	// Add `.onContentChange()` functions to each `comment`.
	// It's used in `loadResourceLinks()` function of `social-components`
	// and returns a list of child comment ids the content of which changed
	// as a result of changing the parent comment content.
	// `Array.find()` is slow for doing it every time.
	// A "get post by id" index is much faster.
	const getCommentById = createByIdIndex(thread.comments)
	for (const comment of thread.comments) {
		let isFirstRunForThisComment = true
		addOnContentChange(comment, (isParentCommentUpdate) => {
			const isFirstRun = isFirstRunForThisComment
			isFirstRunForThisComment = false
			// Set "Deleted message" for links to deleted comments.
			// Set "Hidden message" for links to hidden comments.
			// Autogenerate "in reply to" quotes for links to all other comments.
			const contentDidChange = generateQuotes(comment.content, {
				// `comment` is only used for generating post preview.
				comment,
				getCommentById,
				threadId,
				messages: getMessages(messages),
				isFirstRun,
				isParentCommentUpdate
			})
			if (contentDidChange) {
				generatePreview(comment, configuration.commentLengthLimit)
			}
			return contentDidChange
		})
		comment.parseContent = (options = {}) => {
			if (comment.rawContent) {
				comment.content = comment.rawContent
				delete comment.rawContent
			}
			if (comment.content) {
				// Parse "in-reply-to" comments so that post quotes
				// are autogenerated correclty,
				// but only if the cited comment doesn't have anything
				// except for `post-link`s.
				let shouldBeReParsedLater
				if (comment.inReplyTo) {
					if (options.root === false && canGeneratePostQuoteIgnoringNestedPostQuotes(comment, { messages: getMessages(messages) })) {
						// Don't parse `inReplyTo` comments.
						// But since the comment isn't fully "parsed"
						// in a sense that its autogenerated post link quotes
						// haven't been set yet, then mark this comments for later re-parsing.
						shouldBeReParsedLater = true
						comment.rawContent = comment.content
					} else {
						// Parse `inReplyTo` comments.
						for (const comment of comment.inReplyTo) {
							comment.parseContent({ root: false })
						}
					}
				}
				chan.parseCommentContent(comment, {
					boardId,
					threadId
				})
				if (shouldBeReParsedLater) {
					// Passing `generateQoutes: false` could seem like not making any sense,
					// but it is used in `captchan` when parsing comments not starting from the first one:
					// when "Show previous" button is shown and comments are output from after the "latest read" one.
					// In those cases, when the first shown comment quotes an earlier comment
					// having a manually written quote for a post link, such manually written quotes
					// should be moved inside that `post-link`'s `content`.
					// Example: #1235 ">>1234 \n >Quote \n Text" (hidden), #1236 ">>1235 \n Second text" (shown).
					// Without calling `setInReplyToQuotes({ generateQuotes: false })` it would be:
					// #1236 ">>««Quote» \n Text» \n Second text".
					// With calling `setInReplyToQuotes({ generateQuotes: false })` it would be:
					// #1236 ">>«Text» \n Second text".
					setInReplyToQuotes(
						comment.content,
						getCommentById,
						{
							messages: getMessages(messages),
							generateQuotes: false
						}
					)
				} else {
					// This flag is checked in `onContentChange()`.
					comment.contentParsed = true
					// Update autogenerated quotes in child comments.
					comment.onContentChange()
					// `.parseContent()` method is set to a "no op" function
					// instead of `undefined` for convenience.
					// (because it can be called multiple times in case of a
					//  `virtual-scroller` with `initialState` being passed)
					comment.parseContent = () => {}
				}
			}
		}
	}
	// The "opening" post of a thread is always parsed
	// when showing thread page because it's always immediately visible
	// and also because `title` is autogenerated from it.
	thread.comments[0].parseContent()
	// If `thread.title` is missing then either copy it
	// from the first comment's `title` or attempt to
	// autogenerate it from the first comment's `content`.
	// Also applies censorship rules to `thread.title`
	// if it's either already present or autogenerated.
	generateThreadTitle(thread, {
		censoredWords,
		messages
	})
	// Generate text preview which is used for `<meta description/>` on the thread page.
	generateTextPreview(thread.comments[0], messages)
	setThreadInfo(thread, {
		mode: 'thread',
		votes: UserData.getCommentVotes(boardId, threadId)
	})
	return {
		boardId,
		thread: {
			...thread
		}
	}
}

/**
 * Generates a text preview of a comment.
 * Text preview is used for `<meta description/>`.
 * @param {object} comment
 * @return {string} [preview]
 */
function generateTextPreview(comment, messages) {
	const textPreview = getPostText(comment, {
		ignoreAttachments: true,
		softLimit: 150,
		messages: messages.contentTypes
	})
	if (textPreview) {
		comment.textPreview = trimText(textPreview, 150)
	}
}

/**
 * Adds `onContentChange()` functions to each comment.
 * The `onContentChange()` function should be called
 * whenever the comment content is updated (for example,
 * after a link to a YouTube video is parsed and expanded
 * into an embedded attachment). It re-generates comment
 * preview and also if `expandReplies` is `true` it updates
 * the autogenerated quotes in the comment's replies.
 * Returns an array of ids of replies to this comment whose
 * content did change as a result of this comment content's change.
 * For example, when there're replies to this comment having
 * autogenerated quotes those quotes should be re-generated
 * when this comment's content changes.
 * The returned array of reply ids is used in `loadResourceLinks()`
 * function of `social-components`: each of those reply ids
 * will be used to re-render the corresponding posts.
 * @param {object} comment
 * @return {number[]} [description] Returns an array of ids of replies to this comment whose content did change as a result of this comment content's change.
 */
function addOnContentChange(comment, updateAutogeneratedContent) {
	// `expandReplies: true` option of `imageboard`
	// transforms reply ids into reply comment objects.
	// `expandReplies` must be `true` both here and in `./Chan.js`.
	const expandReplies = true
	// `isParentCommentUpdate` is only passed internally when calling
	// `.onContentChange()` for child comments recursively.
	// `isParentCommentUpdate` should not be passed when calling
	// `.onContentChange()` as a public API.
	// Returns the list of child comment ids whose `content`
	// did change as a result of the parent comment content change.
	comment.onContentChange = (isParentCommentUpdate, options = {}) => {
		const autogeneratedContentDidChange = comment.content &&
			updateAutogeneratedContent(isParentCommentUpdate)
		if (isParentCommentUpdate) {
			if (autogeneratedContentDidChange) {
				// Theoretically there can be cases when a post's content
				// is present is quotes on a deeper nesting level.
				// For example, if a parent post is "Video Title" and a
				// child post is just a quote of the parent post
				// ("> Video Title") and a child-of-a-child comment quotes
				// the child comment ("> > Video Title").
				// Such edge cases are dismissed to keep the code simple
				// so a child-of-a-child comment will be something like
				// "> > (link to youtube.com)" in such case.
				return []
			}
		}
		// Don't recurse into updating replies for potentially less CPU usage.
		// Sometimes replies depend on parent's parent reply content.
		// For example, if comment #1 is "Text" and comment #2 is ">>1"
		// and comment #3 is ">>2" then when comment #1 `content` is paresed
		// then only comment #2 `content` is updated to "> Text" and
		// comment #3 `content` is not updated in this case and will
		// just be a "Message" link. The solution is: don't post comments
		// without the actual content.
		else {
			if (comment.replies && expandReplies) {
				return comment.replies
					.map(reply => reply.contentParsed && reply.content && reply.onContentChange(true) ? reply.id : undefined)
					.filter(_ => _)
			}
			return []
		}
	}
}