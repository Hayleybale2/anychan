import Chan from './Chan'
import setThreadInfo from './utility/setThreadInfo'
import createByIdIndex from '../utility/createByIdIndex'
import getMessages from './utility/getMessages'
import configuration from '../configuration'
import UserData from '../UserData/UserData'

import { generateQuotes, generatePreview, generateThreadTitle } from '../imageboard'

import getPostText from 'webapp-frontend/src/utility/post/getPostText'
import trimText from 'webapp-frontend/src/utility/post/trimText'

export default async function getThread({
	boardId,
	threadId,
	censoredWords,
	messages,
	http
}) {
	const chan = Chan({ censoredWords, messages, http })
	const thread = await chan.getThread({
		boardId,
		threadId
	}, {
		// The parser parses thread comments up to 4x faster without parsing their content.
		// Example: when parsing comments content — 650 ms, when not parsing comments content — 200 ms.
		parseContent: false
	})
	// Add `.onContentChange()` functions to each `comment`.
	// `Array.find()` is slow for doing it every time.
	// A "get post by id" index is much faster.
	const getCommentById = createByIdIndex(thread.comments)
	for (const comment of thread.comments) {
		let isFirstRunForThisComment = true
		addOnContentChange(comment, (isParentCommentUpdate) => {
			const isFirstRun = isFirstRunForThisComment
			isFirstRunForThisComment = false
			// Set "Deleted message" for links to deleted comments.
			// Set "Hidden message" for links to hidden comments.
			// Autogenerate "in reply to" quotes for links to all other comments.
			const contentDidChange = generateQuotes(comment.content, {
				// `comment` is only used for generating post preview.
				comment,
				getCommentById,
				threadId,
				messages: getMessages(messages),
				isFirstRun,
				isParentCommentUpdate
			})
			if (contentDidChange) {
				generatePreview(comment, configuration.commentLengthLimit)
			}
			return contentDidChange
		})
		comment.parseContent = () => {
			if (comment.content) {
				chan.parseCommentContent(comment, {
					boardId,
					threadId
				})
				// This flag is checked in `onContentChange()`.
				comment.contentParsed = true
				// Update autogenerated quotes in child comments.
				comment.onContentChange()
				// `.parseContent()` method is set to a "no op" function
				// instead of `undefined` for convenience.
				// (because it can be called multiple times in case of a
				//  `virtual-scroller` with `initialState` being passed)
				comment.parseContent = () => {}
			}
		}
	}
	// The "opening" post of a thread is always parsed
	// when showing thread page because it's always immediately visible
	// and also because `title` is autogenerated from it.
	thread.comments[0].parseContent()
	// If `thread.title` is missing then either copy it
	// from the first comment's `title` or attempt to
	// autogenerate it from the first comment's `content`.
	// Also applies censorship rules to `thread.title`
	// if it's either already present or autogenerated.
	generateThreadTitle(thread, {
		censoredWords,
		messages
	})
	// Generate text preview which is used for `<meta description/>` on the thread page.
	generateTextPreview(thread.comments[0], messages)
	setThreadInfo(thread, {
		mode: 'comment',
		votes: UserData.getCommentVotes(boardId, threadId)
	})
	return {
		boardId,
		thread: {
			...thread
		}
	}
}

/**
 * Generates a text preview of a comment.
 * Text preview is used for `<meta description/>`.
 * @param {object} comment
 * @return {string} [preview]
 */
function generateTextPreview(comment, messages) {
	const textPreview = getPostText(
		comment.content,
		comment.attachments,
		{
			ignoreAttachments: true,
			softLimit: 150,
			messages: messages.contentTypes
		}
	)
	if (textPreview) {
		comment.textPreview = trimText(textPreview, 150)
	}
}

/**
 * Adds `onContentChange()` functions to each comment.
 * The `onContentChange()` function should be called
 * whenever the comment content is updated (for example,
 * after a link to a YouTube video is parsed and expanded
 * into an embedded attachment). It re-generates comment
 * preview and also if `expandReplies` is `true` it updates
 * the autogenerated quotes in the comment's replies.
 * Returns an array of ids of replies to this comment whose
 * content did change as a result of this comment content's change.
 * For example, when there're replies to this comment having
 * autogenerated quotes those quotes should be re-generated
 * when this comment's content changes.
 * @param {object} comment
 */
function addOnContentChange(comment, updateAutogeneratedContent) {
	// This `expandReplies` variable must be the same as
	// the `expandReplies` parameter in `./Chan.js`.
	const expandReplies = true
	// `isParentCommentUpdate` is only passed internally when calling
	// `.onContentChange()` for child comments recursively.
	// `isParentCommentUpdate` should not be passed when calling
	// `.onContentChange()` as a public API.
	// Returns the list of child comment ids whose `content`
	// did change as a result of the parent comment content change.
	comment.onContentChange = (isParentCommentUpdate) => {
		const autogeneratedContentDidChange = comment.content &&
			updateAutogeneratedContent(isParentCommentUpdate)
		if (isParentCommentUpdate) {
			if (autogeneratedContentDidChange) {
				// Theoretically there can be cases when a post's content
				// is present is quotes on a deeper nesting level.
				// For example, if a parent post is "Video Title" and a
				// child post is just a quote of the parent post
				// ("> Video Title") and a child-of-a-child comment quotes
				// the child comment ("> > Video Title").
				// Such edge cases are dismissed to keep the code simple
				// so a child-of-a-child comment will be something like
				// "> > (link to youtube.com)" in such case.
				return []
			}
		}
		// Don't recurse into updating replies for potentially less CPU usage.
		// Sometimes replies depend on parent's parent reply content.
		// For example, if comment #1 is "Text" and comment #2 is ">>1"
		// and comment #3 is ">>2" then when comment #1 `content` is paresed
		// then only comment #2 `content` is updated to "> Text" and
		// comment #3 `content` is not updated in this case and will
		// just be a "Message" link. The solution is: don't post comments
		// without the actual content.
		else {
			if (comment.replies && expandReplies) {
				return comment.replies
					.map(reply => reply.contentParsed && reply.content && reply.onContentChange(true) ? reply.id : undefined)
					.filter(_ => _)
			}
			return []
		}
	}
}