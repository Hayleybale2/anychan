import React, { useState, useRef, useCallback, useMemo, useLayoutEffect } from 'react'
import PropTypes from 'prop-types'
import classNames from 'classnames'
import { useSelector, useDispatch } from 'react-redux'

import {
	isInstantBackAbleNavigation,
	wasInstantNavigation,
	goBack,
	canGoBackInstantly
} from 'react-pages'

import { setVirtualScrollerState } from '../../redux/thread'
import { getThread } from '../../redux/chan'
import { threadExpired } from '../../redux/threadTracker'

import getMessages from '../../messages'
import { updateAttachmentThumbnailMaxSize } from '../../utility/postThumbnail'

import InReplyToModal from '../../components/InReplyToModal'
import CommentsList from '../../components/CommentsList'
import ShowPrevious from '../../components/ShowPrevious'

import ThreadComment from './ThreadComment'
import ThreadPageHeader from './ThreadPageHeader'
// import BackToPreviousComment from './BackToPreviousComment'

import useFromIndex from './useFromIndex'
import useExpandAttachments from './useExpandAttachments'
import useTrackedThread from './useTrackedThread'
import useThreadNavigation from './useThreadNavigation'
import useSlideshow from './useSlideshow'

import './Thread.css'

function ThreadPage({
	match,
	commentsShownBeforeLatestReadCount
}) {
	const [isSearchBarShown, setSearchBarShown] = useState()
	const [searchQuery, setSearchQuery] = useState()

	// Redux state.
	const board = useSelector(({ chan }) => chan.board)
	const thread = useSelector(({ chan }) => chan.thread)
	const locale = useSelector(({ settings }) => settings.settings.locale)

	// Runs only once before the initial render.
	// Sets `--PostThumbnail-maxWidth` CSS variable.
	useMemo(
		() => updateAttachmentThumbnailMaxSize(thread.comments),
		[thread]
	)

	const [isThreadTracked, setThreadTracked] = useTrackedThread({
		board,
		thread
	})

	// `<VirtualScroller/>`
	const virtualScroller = useRef()
	const _restoredVirtualScrollerState = useSelector(({ thread }) => thread.virtualScrollerState)
	const restoredVirtualScrollerState = wasInstantNavigation() ? _restoredVirtualScrollerState : undefined
	const virtualScrollerState = useRef()

	// "Expand attachments".
	const [areAttachmentsExpanded, setAttachmentsExpanded] = useExpandAttachments({
		restoredVirtualScrollerState,
		virtualScrollerState
	})

	// First shown comment index.
	const [
		fromIndex,
		setNewFromIndex,
		setNewFromIndexPreservingScrollPosition,
		preserveScrollPositionOnPrependItems,
		initialFromIndex,
		isInitialFromIndex,
		latestReadCommentIndex,
		showFromLatestReadComment
	] = useFromIndex({
		board,
		thread,
		location,
		commentsShownBeforeLatestReadCount,
		restoredVirtualScrollerState,
		virtualScrollerState
	})

	const [
		threadNavigationHistory,
		onNavigateToComment,
		onGoBackInThreadNavigationHistory,
		isThreadHistoryModalShown,
		hideThreadHistoryModal
	] = useThreadNavigation({
		thread,
		locale
	})

	const [
		openSlideshow
	] = useSlideshow({
		thread,
		fromIndex,
		setNewFromIndex
	})

	// `<VirtualScroller/>`
	const initialVirtualScrollerCustomState = useMemo(() => ({
		// expandAttachments: false,
		fromIndex,
		latestReadCommentIndex
	}), [
		fromIndex,
		latestReadCommentIndex
	])

	const shownComments = useMemo(
		() => thread.comments.slice(fromIndex),
		[thread, fromIndex]
	)

	const getItem = useCallback(
		(i) => thread.comments[fromIndex + i],
		[thread, fromIndex]
	)

	const dispatch = useDispatch()
	const itemComponentProps = useMemo(() => ({
		// `onPostContentChange()` is passed to `<Post/>`.
		// It's called whenever there's a parent comment who's `content` did change
		// (YouTube video links get loaded, Twitter links get loaded, etc) and there're "replies"
		// to that parent comment having "autogenerated" quotes of that parent comment `content`.
		// So when the parent comment `content` is re-rendered all its "replies" should be
		// re-rendered too and that's what this function is for: it's called for each reply
		// of a post who's `content` did change.
		onPostContentChange(id) {
			const index = thread.comments.findIndex(_ => _.id === id)
			virtualScroller.current.renderItem(index)
		},
		mode: 'thread',
		board,
		thread,
		dispatch,
		locale,
		expandPostLinkBlockQuotes: false,
		expandAttachments: areAttachmentsExpanded,
		onShowComment: onNavigateToComment,
		previouslyRead: (commentId) => {
			if (showFromLatestReadComment && isInitialFromIndex) {
				let i = fromIndex
				while (i < thread.comments.length && i <= fromIndex + commentsShownBeforeLatestReadCount) {
					if (thread.comments[i].id === commentId) {
						return true
					}
					i++
				}
			}
		}
	}), [
		// The dependencies list should be such that
		// comments aren't re-rendered when they don't need to.
		thread,
		areAttachmentsExpanded,
		dispatch,
		onNavigateToComment,
		showFromLatestReadComment,
		fromIndex,
		commentsShownBeforeLatestReadCount,
		isInitialFromIndex
	])

	const onBack = useCallback((event) => {
		if (canGoBackInstantly()) {
			dispatch(goBack())
			event.preventDefault()
		}
	}, [dispatch])

	const onGoToComment = useCallback((comment) => {
		const index = thread.comments.indexOf(comment)
		if (index < 0) {
			throw new Error(`Comment ${comment.id} not found`)
		}
		setNewFromIndex(index)
	}, [
		thread,
		setNewFromIndex
	])

	const onShowAll = useCallback(() => {
		setNewFromIndex(0)
	}, [
		setNewFromIndex
	])

	// useLayoutEffect(() => {
	// 	// scroll here.
	// }, [])

	return (
		<section className={classNames('ThreadPage', 'Content')}>
			<ThreadPageHeader
				board={board}
				thread={thread}
				onBack={onBack}
				locale={locale}
				openSlideshow={openSlideshow}
				isThreadTracked={isThreadTracked}
				setThreadTracked={setThreadTracked}
				isSearchBarShown={isSearchBarShown}
				setSearchBarShown={setSearchBarShown}
				areAttachmentsExpanded={areAttachmentsExpanded}
				setAttachmentsExpanded={setAttachmentsExpanded}/>
			{fromIndex > 0 &&
				<ShowPrevious
					fromIndex={fromIndex}
					setFromIndex={setNewFromIndexPreservingScrollPosition}
					items={thread.comments}
					onShowAll={onShowAll}
					locale={locale}/>
			}
			<div className="ThreadPage-commentsContainer">
				{/*!searchQuery && threadNavigationHistory.length > 0 &&
					<BackToPreviousComment
						locale={locale}
						onClick={onBackToPreviouslyViewedComment}/>
				*/}
				{searchQuery &&
					<CommentsList
						key="searchResults"
						mode="thread"/>
				}
				{shownComments.length > 0 && !searchQuery &&
					<CommentsList
						key="comments"
						ref={virtualScroller}
						mode="thread"
						getItem={getItem}
						initialCustomState={initialVirtualScrollerCustomState}
						restoredState={restoredVirtualScrollerState}
						setState={setVirtualScrollerState}
						stateRef={virtualScrollerState}
						items={shownComments}
						itemComponent={ThreadComment}
						itemComponentProps={itemComponentProps}
						preserveScrollPositionOnPrependItems={preserveScrollPositionOnPrependItems}
						preserveScrollPositionAtBottomOnMount={initialFromIndex === thread.comments.length}
						className={classNames('Comments', 'ThreadPage-comments', {
							// 'ThreadPage-comments--fromTheStart': fromIndex === 0
						})}/>
				}
				{/*noNewComments &&
					<p className="ThreadPage-noNewComments">
						{getMessages(locale).noNewComments}
					</p>
				*/}
			</div>
			{threadNavigationHistory.length > 0 &&
				<InReplyToModal
					board={board}
					thread={thread}
					isOpen={isThreadHistoryModalShown}
					onClose={hideThreadHistoryModal}
					onGoBack={onGoBackInThreadNavigationHistory}
					history={threadNavigationHistory}
					onShowComment={onNavigateToComment}
					onGoToComment={onGoToComment}/>
			}
		</section>
	)
}

ThreadPage.propTypes = {
	match: PropTypes.shape({
		location: PropTypes.shape({
			hash: PropTypes.string
		}).isRequired
	}).isRequired,
	commentsShownBeforeLatestReadCount: PropTypes.number.isRequired
}

ThreadPage.defaultProps = {
	commentsShownBeforeLatestReadCount: 0
}

ThreadPage.meta = ({ chan: { board, thread }}) => ({
	title: thread && thread.title || board && board.title,
	description: thread && thread.comments[0].textPreview,
	image: thread && getThreadImage(thread)
})

ThreadPage.load = async ({ getState, dispatch, params }) => {
	const boardId = params.board
	const threadId = parseInt(params.thread)
	try {
		await dispatch(getThread(
			boardId,
			threadId,
			getState().settings.settings.censoredWords,
			getState().settings.settings.locale
		))
	} catch (error) {
		if (error.status === 404) {
			// Clear expired thread from user data.
			dispatch(threadExpired({ boardId, threadId }))
		}
		throw error
	}
}

function getThreadImage(thread) {
	const comment = thread.comments[0]
	if (comment.attachments && comment.attachments.length > 0) {
		for (const attachment of comment.attachments) {
			switch (attachment.type) {
				case 'picture':
					return attachment.picture.url
				case 'video':
					return attachment.video.picture.url
			}
		}
	}
}



// This is a workaround for cases when `found` doesn't remount
// page component when navigating to the same route.
// https://github.com/4Catalyzer/found/issues/639
export default function ThreadPageWrapper({ match }) {
	const board = useSelector(({ chan }) => chan.board)
	const thread = useSelector(({ chan }) => chan.thread)
	return <ThreadPage key={`${board.id}/${thread.id}`} match={match}/>
}
ThreadPageWrapper.meta = ThreadPage.meta
ThreadPageWrapper.load = ThreadPage.load
ThreadPageWrapper.propTypes = {
	match: PropTypes.shape({
		location: PropTypes.shape({
			hash: PropTypes.string
		}).isRequired
	}).isRequired
}