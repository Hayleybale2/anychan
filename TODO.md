// react-website: add @serverSideRender(({ children: string }) => string) (и убрать `renderContent: false`, включая readme и -example)

// Мб сделать в `react-pages` что-нибудь, чтобы последний компонент route'а всегда re-mount-ился при смене location, даже если URL остался тем же: это решит те случаи, когда, например, на странице есть ссылка на саму себя. Но это редкие случаи.

`react-pages`: Не unmount-ит страницу текущего треда при переходе по ссылке другого треда. https://github.com/4Catalyzer/found/issues/639







On select text — show "Reply" button at bottom center.







<CommentWithThumbnail onDoubleClick={hidden ? undefined : onReply}/>

and onLongPress:

Comment
Comment-thumbnail
Comment-thumbnailPlaceholder
CommentAuthor
PostTitle
PostContent > PostParagraph
PostContent > PostVideo
PostContent > PostPicture
PostContent > PostEmbeddedAttachmentTitle
PostContent
CommentFooter
CommentFooter-left
CommentFooter-right







Разрешить заходить в настройки (и менять адрес прокси-сервера), если не загрузились доски (писать можно в сайдбаре: "Не удалось загрузить список досок", или просто "Error").





ThreadActivityIndicator — tick after currently viewed thread auto-update is enabled.




### virtual-scroller

`getScrollableContainer` -> `scrollableContainer`

Maybe support `scrollableContainerRef` in ReactVirtualScroller

`virtual-scroller`: если scroll был через page up / page down, то не делать задержку перед подгрузкой следующей страницы item-ов.

update `virtual-scroller`







Рендеренный документ не всегда соответствует state-у у React'а, поэтому посмотреть, чтобы не использовало state из документа: посмотреть все ref= и ref:, offsetHeight, childNodes, etc

Посмотреть, как используется onItemFirstRender, и не может ли быть там рассинхронизации с items.





Можно затемнять слайдшоу при начале листания.

Перестали работать overlayOpacityFlowMode и overlayOpacitySmallScreen.





Если у поста нет текстового контента, то можно показывать minimized автосгенерированные цитаты.









В exit drag and scale mode делать setState, и потом уже animation через CSS.

На десктопе показывать кнопку "exit drag and scale mode" где-нибудь вверху экрана посередине (до правого верхнего угла тянуться далеко).

При показе слайда — затенять thumbnail

Если зумить аут на мобильном, то можно сразу закрывать слайдшоу в иконку на малых экранах.









### Ответ по long press / double click

function onLongPress(element, callback) {
  let timer;

  maybe compare event.changedTouches.id ... and cancel on multi-touch

  element.addEventListener('touchstart', () => {
    timer = setTimeout(() => {
      timer = null;
      callback();
    }, 500);
  });

  function cancel() {
    clearTimeout(timer);
  }

  element.addEventListener('touchend', cancel);
  element.addEventListener('touchmove', cancel);
}

+ add "pop" animation like in telegram.

maybe increase time to 1000 ms.

maybe add mousemove tolerance (4px or so).

по тачу: небольшая задержка (мб миллисекунд 150), затем небольшое затемнение и уменьшение, потом bounce обратно.

Если double click прямо на `target` === `thread-comment` или `thread-comment__post-and-stats`, либо внутри `thread-comment__stats`, то можно входить в режим ответа. То же самое — force touch можно сделать с такими условиями срабатывания. При нажатии на "Ответить" из меню — переходить в режим ответа и показывать сверху от формы ответа мб notification: "Отвечать на комментарии можно также двойным нажатием на краю комментария, или через long press (touch или мышь)".

Ответ на сообщение — мб через меню либо через двойной клик либо через долгое нажатие мб.






### Thread Activity Status

on getThreads(), do `for (thread of threads) dispatch(updateThread(thread))`.
on getThread(), do `dispatch(updateThread(thread)`.
on refreshTrackedThread(), do `dispatch(updateThread(thread)`.
in updateThread(): refresh `ThreadActivityStatus`.

Показывать кружок статуса активности треда слева от счётчика комментариев в: catalog, thread, tracked threads.








### Автообновление треда

Сделать автообновление треда при прочтении самого позднего на текущий момент времени сообщения в нём. Если вкладка visible, то обновлять можно чаще. Статус автообновления писать под комментариями треда: "Обновление через ... с" ("Refresh in ... s"). Или, чтобы не тикало, можно писать "Обновлено ... мин ранее".

Можно сделать не полоску, а часы такие как бы, на которых время как бы "истекает", и превращается в кружащийся почти круг, который вращается при обновлении, и там уже можно писать: "Обновлено только что", или "Обновлено 1 мин. ранее", для чего будет составляться свой какой-то style мб, с "just now", копирующий стиль твиттера. Изначально писать там время загрузки треда, для чего его где-то класть в redux.thread после выполнения getThread(). В tooltip-е на часах можно писать: "Обновление через ... с".

[
	{
		factor: 1,
		unit: 'now'
	},
	...twitter
]


[
	{
		factor: 1,
		unit: 'now'
	},
	...twitter
]
	{
		factor: 1,
		unit: 'seconds'
	},



Обновлять всю фигню в `trackedThreads` во время "Автообновления" открытого треда.









После того, как будет сделан ответ на комментарии, проверить VirtualScroller state: ввести текст, приаттачить картинку, затем "Назад"/"Вперёд".







Проверить возможность ответа на комментарий, показанный в модальном окне, появляющемся по клику на цитате.

После отправки комментария — всплывающее уведомление с текстом типа "Комментарий отправлен. Посмотреть", где текстовая кнопка "Посмотреть" показывала бы тред, начиная с добавленного комментария как единственного непрочитанного.










Можно добавить возможность скрывать ветку (типа "срача"). Потому что в таких случаях не скрывается по id автора, т.к. они только на спец досках.






Может быть сделать кнопку "посмотреть ответы" у тредов на странице доски, которая будет загружать и показывать несколько самых поздних комментариев прямо там же, "инлайново", без ухода со страницы.










### Обновление отслеживаемых тредов


Время давности — время наиболее недавнего обновления минус время наиболее недавнего комментария (`trackedThread.latestComment.createdAt`). Время наиболее недавнего обновления — `trackedThread.refreshedAt || trackedThread.addedAt`.


Если время давности до 5 минут, то интервал обновления — 30 секунд.
Если время давности до 10 минут, то интервал обновления — 1 минута.
Если время давности до 15 минут, то интервал обновления — 2 минуты.
Если время давности до 30 минут, то интервал обновления — 3 минуты.
Если время давности до часа, то интервал обновления — 5 минут.
Если время давности до 3 часов, то интервал обновления — 10 минут.
Если время давности до 6 часов, то интервал обновления — 20 минут.
Если время давности до 12 часов, то интервал обновления — 25 минут.
Если время давности до 24 часов, то интервал обновления — 30 минут.
Если время давности до 7 дней, то интервал обновления — час.
Если время давности до 14 дней, то интервал обновления — 3 часа.
Если время давности до 30 дней, то интервал обновления — 12 часов.
Если время давности более 30 дней, то интервал обновления — 24 часа.


const REFRESH_INTERVALS = [{
	interval: 30 * 1000
}, {
	threshold: 5 * 60 * 1000,
	interval: 60 * 1000
}, {
	threshold: 10 * 60 * 1000,
	interval: 2 * 60 * 1000
}, {
	threshold: 15 * 60 * 1000,
	interval: 3 * 60 * 1000
}, {
	threshold: 30 * 60 * 1000,
	interval: 5 * 60 * 1000
}, {
	threshold: 60 * 60 * 1000,
	interval: 10 * 60 * 1000
}, {
	threshold: 3 * 60 * 60 * 1000,
	interval: 20 * 60 * 1000
}, {
	threshold: 6 * 60 * 60 * 1000,
	interval: 25 * 60 * 1000
}, {
	threshold: 12 * 60 * 60 * 1000,
	interval: 30 * 60 * 1000
}, {
	threshold: 24 * 60 * 60 * 1000,
	interval: 60 * 60 * 1000
}, {
	threshold: 7 * 24 * 60 * 60 * 1000,
	interval: 3 * 60 * 60 * 1000
}, {
	threshold: 14 * 24 * 60 * 60 * 1000,
	interval: 12 * 60 * 60 * 1000
}, {
	threshold: 30 * 24 * 60 * 60 * 1000,
	interval: 24 * 60 * 60 * 1000
}]

Background refresh чтобы не конфликтовал с cached local storage (visibility change): если thread watched, то записывать прочитанность сразу, чтобы не было ситуаций, когда уже прочтено много, но ещё не отмечено, а браузер обновляет в фоне, и говорит, что столько-то непрочитанных. Также, при записи на диск обновлять счётчик непрочитанных в отслеживаемых тредах (таким образом устраняя race condition).






При загрузке каталога: сверять время изменения и кол-во комментариев, и если отличается, то можно обновлять tracked threads.












### Tracked threads list

Вместо количества новых комментариев мб показывать просто не особо выделенную точку, чтобы не было "obsessive compulsive".








### Открытие страницы треда на мобильных

На загружаемых страницах на мобильных можно сделать индикатор "три "мигающих" (увеличиваются-уменьшаются) квадратика".

Делать ли наезд новой страницы в стиле навигатора на мобильных.








После первого ответа в тред, можно показывать форму ответа развёрнутой (по самым нижним комментарием) — режим чата, как вконтакте.

При новом комментарии (в том числе ответе) в отслеживаемом треде показывать уведомление как вконтакте (остающееся на экране, схлопывающееся в рамках одного треда в "гармошку" как уведомления на айФоне, без разъезжания по клику). При нажатии на такое уведомление открывать мини-окошко треда, как если бы это было окошко переписки вконтакте (с подобных "лейаутом"). В заголовке окошка ("/b/123 Название") — ссылка на тред в "нормальном" режиме. Таким образом можно будет удобнее отвечать на комментарии и "чатиться" в треде. Мини-окошки — перетаскиваемые мышью, и поверх всего.

Вышеописанное описано для случая, когда вкладка открыта (реализованное на каждой из вкладок и синхронизируемое между ними). Если страница была открыта после того, как поступили новые комментарии, то при нажатии на тред в избранном открывать тред в "нормальном" режиме, а не в окошке. Аргументация: мини-окошки удобны тогда, когда пользователь уже занят чем-то другим, и его не нужно отвлекать, чтобы не "терять контекст" переходом с одной страницы на другую. Когда же пользователь только что открыл вкладку, он ещё ничем не занят, поэтому ссылкам в "Избранном" логично вести на треды в "нормальном" режиме. Когда же пользователь уже находится на открытой вкладке, и пришло уведомление, то у пользователя есть выбор: либо нажать на такой тред в избранном (там он "поднимется" автоматически, и загорится счётчик), и перейти на этот тред в "нормальном" режиме, либо нажать на всплывшее уведомление, и открыть тред в режиме "мини-окошка" чата.

Настраиваемые хоткеи можно сделать на слайдшоу, развернуть картинки и добавить в избранное


Если прочитанность по скроллу, то делать задержку, чтобы соучайный скролл не помечал прочтённость (мб секунду).

Прочитанность - либо по событию скролла (даже если уже некуда крутить), либо по не переключению и не закрытию вкладки в течение какого-то времени после активности, и потом ещё активность, мб время зависит от длины текста.






Deploy gh pages with base path config.

Comment read status watcher: read, if appears after scroll and was mounted before scroll; read, if appears on screen and then some user input happens (touch, click, keydown) and it's still visible for half a second, or a scroll happens.





How ReCaptcha works:
https://www.blackhat.com/docs/asia-16/materials/asia-16-Sivakorn-Im-Not-a-Human-Breaking-the-Google-reCAPTCHA-wp.pdf

Invisible ReCaptcha:
https://tehnoblog.org/google-no-captcha-invisible-recaptcha-first-experience-results-review/#google-invisible-recaptcha-v2.0

How does Google reCAPTCHA v2 work.
https://stackoverflow.com/questions/27286232/how-does-google-recaptcha-v2-work-behind-the-scenes





<script>
	let googleReCaptchaLoaded
	let googleReCaptchaElement
	function onGoogleReCaptchaLoad() {
		console.log('ReCaptcha loaded')
		googleReCaptchaLoaded = true
	}
</script>

<script src="https://www.google.com/recaptcha/api.js?onload=onGoogleReCaptchaLoad&render=explicit" async defer></script>

<script>
	// Shows post reply form.
	const onPostReply = () => {
		if (!googleReCaptchaLoaded) {
			return alert('Google ReCaptcha not loaded')
		}
		if (!googleReCaptchaElement) {
			googleReCaptchaElement = document.createElement('div')
			document.body.appendChild(googleReCaptchaElement)
		}
		// grecaptcha.hl = locale
		grecaptcha.render(googleReCaptchaElement, {
	    sitekey: 'your_site_key',
			size: 'invisible',
			// badge: 'inline', // CSS positioning.
	    callback: (gReCaptchaResponse) => {
	    	alert(gReCaptchaResponse)
			}
		})
	}

	const onSubmitReply = () => {
		grecaptcha.execute()
	}
</script>



ReCaptcha domain validation:
https://developers.google.com/recaptcha/docs/domain_validation

https://security.stackexchange.com/questions/149324/why-bother-validating-the-hostname-for-a-google-recaptcha-response



Captcha links:

Captcha in mobile apps

https://github.com/mishamoix/Channy/issues/5

2ch wiper

https://github.com/tsunamaru/mobile-wiper/blob/master/app/src/main/java/com/bund/wishmaster/Captcha.java

The Chan

https://github.com/acedened/TheChan.iOS/issues/472

2ch public captcha key:

6LeQYz4UAAAAAL8JCk35wHSv6cuEV5PyLhI6IxsM





Имеется вот такая мобильная капча:
https://2ch.hk/api/captcha/recaptcha/mobile

При этом она выдаёт заголовок:
X-Frame-Options: SAMEORIGIN

Из-за этого, её не использовать в <iframe/>.
Чем вызвана такая строгость по отношению именно к <iframe/>?

Также, эта страница передаёт какой-то странный "callback": "callback: function(a) { window.external.notify(JSON.stringify(a)); }".
Вместо этого, можно было бы делать: "callback: function(a) { parent.postMessage("g-captcha-response", JSON.stringify(a)); }".

"window.external.notify" — это какой-то способ связи с C# приложениями. Зачем он здесь? Могли бы, как минимум, проверять, если ли вообще такая функция, и если она есть, то вызывать, а если её нет, то слать сообщение в parent фрейм.

Иначе, нет никакой связи из фрейма в основную страницу, и, соответственно, основная страница не получит g-captcha-response.




Использование пасскода при работе с API:
https://github.com/8of/2ch-Browser-iOS/blob/50b75569a79950b0418fb18d5ee508ed3b6ef24e/API-DOC/README.md




Не показывать дату для тредов в режиме "Все".

Передизайнить карточки тем на мобильных: сделать иконку слева маленькой, и дальше мало текста, и количество комментариев только мб показывать, или и их, и аттачментов, и маленькими иконками где-нибудь, мб сверху тоже.

При переходе по цитатам сообщений — крутить в середину мб только при возврате на "изначальное" сообщение (то, с которого начинались переходы).

Если открыть видео (обычное) в полном экране, и оно дойдёт до конца, то фокус переместится на страницу, и пробел будет её листать, а стрелки не будут переключать слайды.

Scroll smoothly to replies if they're not on screen, highlight comment on "go to comment".

Create translation thread on kohlchan.

Сделать настройку "Дополнительные стили" (Additional styles).

На `post-link`-и, не развёрнутые в блоки цитат, вида "(комментарий)" — тоже вешать `onPostLinkClick`.

Если есть инлайновая ссылка на комментарий, то подставлять текст комментария инлайново, короткий (если из того же треда). Иначе: "[другой тред]" или "[комментарий из другого треда]".

Можно сделать переключатель "Все" / "Новые" на странице доски.

Можно сделать кнопку автообновления доски (как у треда, только вверху), и показывать точку, если есть вероятность новых комментариев (updateAt есть и не равен предыдущему, или commentsCount не равен предыдущему, но это не гарантия, т.к. могут быть удалены комментарии — добавить этот комментарий в код).

Можно сделать перемотку на "Show previous" комментарий так же, как сейчас сделано "Show all".

Мб использовать `position: fixed` вместо `position: sticky` для кнопки "Return".

Ссылки на треды и доски двача преобразовывать во внутренние (то же самое для форчана и т.п.).

Сделать настройки модальным окном на десктопах, и на мобильных — внутри сайдбара с кнопкой-крестиком.




Если ответить из окна "В ответ на" — закрывать это окно.




Можно сделать запись и отправку голосовых сообщений.



Может быть сделать что-то типа `position: fixed` кнопки внизу "Show most recent comments" ("Показать последние комментарии"), которая будет видна только при заходе в тред, в котором нет прочитанных или есть прочитанные, но количество непрочитанных больше сотни, например, и которая будет пересоздавать VirtualScroller так, как если бы все остальные, кроме самих недавних, были бы уже прочитанными (можно так их и помечать сразу, потому что они и так будут помечены как прочитанные при показе самих недавних комментариев). Также показывать, если впоследствии нажал "Показать все".





На мобильных мб выделить кнопку «к предыдущему комментарию» рамкой, а то её не заметно.

Анимированно крутить при переходе по `post-link`, если разница — в пределах пары экранов. `element.scrollIntoView({ ... smooth ... })`.

При переходе по `post-link` можно крутить не так, чтобы верх комментария был вверху экрана, а чтобы комментарий центром своим был по центру экрана (если влезает) или верхом к верху экрана (если не влезает). Кнопку «к предыдущему комментарию» тогда можно переместить вниз (на десктопах), и мб добавить ей `rrui__button--float`.

При переходе по ссылке `boardId/threadId#commentId` — показывать, начиная с этого комментария.

Возможно как-то подсвечивать комментарий при переходе на него по нажатию на `post-link`, т.к. комментарий может быть где-то внизу страницы, и скролл до него не докрутит, и вообще, сразу не понятно зрением, на какой комментарий прокрутило (UX). Мб также подсвечивать комментарии, когда навигация идёт обратно через кнопку "back to previous comment".

Если цитируемый комментарий был удалён модератором, или если это rolling тред, то какое-нибудь сообщение показывать по клику на цитату.

Что делать, когда пользователь нажимает на цитату комментария, который ещё пока не показан ("Показать предыдущие"): мб как-то сначала показывать "предыдущие", а потом крутить на комментарий как-то. А мб и нет.

Можно как-то убирать из истории перехода по цитатам комментариев записи, когда итак уже докрутил до какого-то комментария из истории (когда его верхняя граница стала видна на экране). При этом просто отметки top в истории не подойдут, т.к. пользователь может нажать "Показать предыдущие", и все top "съедут". Можно сделать через `IntersectionObserver`, как `<CommentReadStatusWatcher/>`.

Сделать учёт scale в slideWidth/slideHeight в Slideshow — просто пока изначального (и мб по колесу/стрелкам), чтобы маленькие видео webm скейлились при запуске.

Сделать анимацию перехода на страницу треда со страницы доски для мобильных через `prevChildren`. Добавить потом коммент сюда: https://github.com/4Catalyzer/found/issues/596 (что сделал). При этом нормально обрабатывать scroll position. Например: на странице доски прокрутить вниз, нажать на тред, там тоже прокрутить, затем нажать кнопку "назад": далее содержимое страницы треда переезжает в `<div/>` с `position: fixed`, и ему ставится scroll, равный скроллу <body/> до навигации, а у <body/> восстанавливается скролл страницы доски. При сдвигании новой страницы, старая сдвигается где-то на четверть. Анимацию погуглить как ios navigation animation css. Не показывать на средних и больших экранах.

Добавить возможность поиска по доске/треду (`getPostText()`). При поиске не учитывать регистр. `const [searchQuery, setSearchQuery] = useState()`. `<VirtualScroller key="searchResults"/>`. `<VirtualScroller key="comments"/>`. Check that Back/Forward state remains on board page. Отключать клики на `post-link` в режиме поиска.





Для сайдбара на планшетах можно добавить overlay, который будет дисейблить остальную страницу, мб немного затемнять её, и закрывать сайдбар по клику на overlay.

При навигации из сайдбара — сворачивать его по началу навигации, а не по окончанию.

При нажатии на тред на странице доски: делать сразу наезд на страницу треда, где показывать первый пост, а под ним — писать что-нибудь типа "Загрузка...", и полоска снизу ездящая (как в адидасе). Таким образом, `.load()` будет работать по-разному: в зависимости от `window.previousRoute` (если `board` - тот же: брать из state.threads текущую по id, и если найдена, то делать так, а если не найдена, то загружать по классике).

На мобильных: при нажатии на доску в сайдбаре — скрывать его анимированно, а на странице доски показывать тоже пустоту и "Загрузка...". Смысл в том, что пока анимация сайдбара заканчивается, проходит какое-то время, и это как бы немного сокращает время ожидания загрузки списка тредов.

На мобильных (малых экранах) не показывать `<Loading/>` для `isBoardLocation()` и `isThreadLocation()`. Вместо этого — карточки в стиле инстаграма (переливающиеся). При загрузке доски: показывать её название (как в header, так и в page__header), и, например, 100 карточек. При загрузке треда: показывать первый комментарий и карточки (по количеству комментариев, минимум одну), обновлять название в header'е. После загрузки треда: обновлять комментарий (мог измениться) — полностью, включая счётчики ответов и картинок.

Каким будет переход на мобильных, когда жмут на отслеживаемый тред? Каким будет переход на мобильных, когда жмут на тред, в котором уже есть прочтённые сообщения? В этих случаях не будет показан начальный комментарий. Видимо, будет показана просто страница с плейсхолдерами комментариев + show previous link (если есть какие-то прочитанные комментарии в треде).

`react-pages` — отключать instantBack-функциональность, пока идёт загрузка страницы (от UPDATE_MATCH до RESOLVE_MATCH): в таких случаях ссылки и goto() будут как обычная навигация.









Сделать нормальный скейлинг для слайдов: анимировать slide width и height + `this.slideshow.scale.offsetX`, `this.slideshow.scale.offsetY`.

Сделать scale больше maxScale (например, для мобильных): на них может потребоваться разглядеть картинку при маленькой ширине экрана (например, текст) — таких случаях будет показываться кнопка "Zoom Out", курсор будет "grab", и перетаскивание будет.

Переделать scale через requestAnimationFrame() и без transform, и убрать у Picture pixel ratio multiplier.

Проверить потом pinch zoom slideshow.






Добавить версию пакета внизу в footer copyright (версию из `package.json`).





Список тредов доски: "Все"/"Новые". `lynxchan` не предоставляет `thread.createdAt`: вместо этого можно сортировать все треды доски по `thread.id`.





Рефрешить треды в трекере "по-умному": активные треды рефрешить чаще (учитывать как-то и рефреши автообновления треда).





`thread.willExpireSoon` пока отключён: если на страницу треда (либо прямо, либо с доски), то для получения такой информации предполагается делать отдельный запрос `/catalog.json` (или "облегчённый" его вариант), что на `2ch.hk` занимает 100 KB (`/threads.json`), а на `4chan.org` — 0.5 KB (`/threads.json`), поэтому можно включить это дело на `4chan.org`. `lynxchan` — не предоставляет какого-то "облегчённого" `/thread.json`.

А можно просто сделать кликабельным время наиболее позднего комментария, поставить тултип "Click to refresh thread status", и показывать справа либо стрелку вправо-вверх "Thread is on place x of y: it's not expiring for now", либо стрелку вправо-вниз.

С другой стороны, кто будет жать эту кнопку...

`threadExpiresSoon.replace('{0}', 1).replace('{1}', 2)`




Как-то генерировать (мб через canvas) иконку чана с красной точкой, и показывать её в favicon, когда есть новые комментарии в открытом треде, или если есть новые ответы в каком-то из отслеживаемых тредов.




Делать sortAndTrimTrackedThreads() при обновлении отслеживаемых тредов (background update).







Если пользователь докрутил до конца комментариев — запускать обновление автоматически.
Обновление: кнопка "Refreshing in ... mins/secs" (`javascript-time-ago`), и внизу полоска, которая тикает справа налево.
Если нажать на кнопку: запускается "Refreshing..." (или когда дотикает).
Полоску при этом можно начинать анимировать как у кнопки в rrui.
Далее, в конце обновления — возвращается на исходные позиции, и снова тикает.

При доскролле до конца - запускать автообновление, но не с момента запроса новых комментариев, а с полоски обратного отсчёта ("Автообновление через ..."). Автообновление будет делать запрос новых комментариев только если `now - threadLoadedAt >= getInterval(comments)`. Таким образом получится, что для тредов, в которых самый поздний коммент был больше суток - не будет сразу слать запрос при доскролле до конца.

Если появились новые комментарии: показывает слева счётчик на фоне "base-color" с рамкой "content-color" (или shadow), и стрелка вниз под счётчиком. Всё это "кликабельное", и анимированно скроллит до первого нового комментария в центре экрана — смотреть высоту List'а до новых, и крутить так, чтобы этот уровень оказался, например, на 2/3 снизу по высоте (если там есть, куда крутить, а то может не быть пространства для кручения — тогда останавливать кручение на том уровне, до которого можно докрутить).
Если появились новые ответы: показывает notification-ы во всех вкладках, плюс обновляет счётчик в сайдбаре в отслеживаемых тредах, а также счётчик на кнопке меню, если это не текущий тред, который автообновляется. Поэтому рефрешер будет какой-то общий на все вкладки. Содержимое уведомления: текст комментария (`getPostSummary()`, без `post-quote`s), ограниченный по длине. Плюс слева можно вставлять первый аттачмент (если он есть — картинка или видео) — тогда если пустой `getPostText()`, то не выводить ещё и текст, чтобы не получилось: картинка и текст "Картинка".
По нажатию на notification — переходит в тред, и показывает начиная с новых комментариев.
Если в том же треде, и включено автообновление — крутит на новые комментарии.
По прочтению очередного комментария — обновлять как счётчик слева, так и счётчик в сайдбаре в отслеживаемых тредах, так и счётчик ответов на кнопке меню.

При автообновлении треда — сначала делать какой-то `window.Thread.requested()`, возвращающий объект `{ cancelled: true/undefined }`, с методом `cancel()`, который будет вызываться внутри .`requested()` для предыдущего `requested`-треда. Таким образом, если автообновление будет запущено, и затем, не дождавшись, пользователь перейдёт в другой тред, то сообщения этого другого треда не будут перезатёрты в Redux state.

Во время автообновления треда какие-то комментарии могли измениться, а какие-то — быть удалены. Поэтому сравнивать предыдущие и новые `comments[]` по `comment.id`, и если каких-то уже нет, то вставлять на место удалённых placeholder, который рендерить как "Удалённый комментарий" (как "Скрытый комментарий").

Прочитанность комментария: если он появился на экране нижней границей в результате scroll down, или если пробыл на экране нижней границей как минимум секунду со времени своего появления и времени какого-либо user input'а (mouse move, key down, touch down, mouse down).

Сейчас сообщение помечается как прочитанное при первом появлении его нижней границы на экране. Но в случаях, когда сообщения автоматически догружаются, пользователь может уже закрывать страницу, а новое сообщение появится, и пометится прочитанным, а пользователь его не прочёл. Поэтому сделано прочитанность нормально — так, как описано выше.

Прочитанность сообщений при открытом сайдбаре — не считать. Запускать все таймеры прочитанности заново после закрытия сайдбара (очищать их при открытии сайдбара).

Если будет введено автообновление, то появившиеся комментарии добавлять либо в прочитанные, либо в ShownCommentsAwaitingUserInputToBeRead (мб где-то в Redux state), которая будет проверяться глобальными хендлерами, установленными на window в Application on mount (и убираемыми по unmount).

Проверить, что счётчики новых комментариев в списке отслеживаемых тредов обновляются при прочтении комментариев в треде.

















`thread.updatedAt` seems to be present in all currently supported engines: show it in `/catalog` view on thread cards. Maybe to the right of the "comments count"/"attachments count" icons. Иконка — мб циферблат ("time icon"). Tooltip: в зависимости от того, какой chan — у `4chan` будет "the last time the thread was modified (post added/modified/deleted, thread closed/sticky settings modified)". У `lynxchan` — "last time this thread was bumped". У `makaba` — наверное, так же, как и у `4chan`.

`post-link`s: rename `postWasDeleted` -> `deleted`, `postIsHidden` -> `hidden`, `postIsExternal` -> remove and compare `boardId` and `threadId` instead. `deleted` — Maybe add to `webapp-frontend`, other -> only in `captchan` (perhaps).

В превью тредов не подставляет "Комментарий" на месте ссылок на посты ("Прошлый тред 31225129 (OP)").

Если текст `post-link` оканчивается на " OP", то можно делать не "(комментарий)", а "(тред)".

Вместо круглых скобок делать квадратные (`[]`).

`messages.thread.default = Тред`, `messages.thread.external = Другой тред`. Цвет — тоже серый, как для удалённых сообщений. Плюс серый цвет для всех external `post-link`s в виде цитат.

Block post links:

* `deleted` комментарии — делать без ссылки и серым цветом и в виде autogenerated post-link quote.
* `external` комментарии — делать просто ссылкой `service link` с иконкой обычной ссылки (без post link quote).
* `hidden` комментарий делать в виде post-link quote (тоже цветом каким-нибудь, мб серым).
* `default` — не бывает такого случая.

Inline post links:

* `deleted` комментарии — делать lowercase и в скобках, обычной ссылкой.
* `external` комментарии — делать lowercase и в скобках, ссылкой `service link` с иконкой обычной ссылки.
* `hidden` комментарий — делать lowercase и в скобках, обычной ссылкой.
* `default` комментарий — делать lowercase и в скобках, обычной ссылкой.

Кнопку мобильного меню можно сделать пожирнее в нажатом состоянии, поместить её посередине, и меню сделать выезжающим справа.

Можно переименовать isSticky -> sticky, isRolling -> rolling, isClosed -> closed, isNotSafeForWork -> notSafeForWork, isSageAllowed -> ..., areNamesAllowed -> ..., isBumpLimitReached -> bumpLimitReached, isAttachmentLimitReached -> attachmentLimitReached, areSubjectsAllowed -> ..., areAttachmentsAllowed -> ..., areTagsAllowed -> ..., hasVoting -> ..., isThreadAuthor -> threadAuthor (неа, другой смысл — как если бы это был ID автора треда), isSage -> sage.

Дополнить imageboard/4chan/parseBoard:
https://github.com/4chan/4chan-API/blob/master/pages/Boards.md

Colored person icons are too small — make it a large colored block like on `4chan.org`. Color the hash with white color. The background colors should be saturated and not too light (and not too dark).

Don’t show remove button on non-expired tracked threads.

Вместо "Комментарий" можно писать "Комментарий из другого треда".

Можно выделять автосгенерированные цитаты другим цветом, чем "зелёные цитаты", написанные людьми. (мб жёлтый, мб оранжевый, мб синий).

Можно сделать настройку "не заменять ссылки на комментарии автосгенерированными цитатами", а то пользователи могут жаловаться, что им так непривычно.

Возможно раскрывать ссылки на комментарии по нажатию прямо на месте, но на том же уровне, без вложенности. Тогда картинку слева убирать под пост, видимо. У развёрнутого поста: сверху и снизу кнопки «свернуть»; по нажатию — сворачивают и сохраняют скролл (кнопка снизу); пост развёрнутый — аттачмент не выносить влево; кнопку показа ответов на развёрнутый пост можно не показывать; при клике на дату развёрнутого поста — сворачивать его и перематывать на этот пост.








На странице доски сделать две вкладки: "Все" и "Новые" (или: "Новые ответы" ("New comments") и "Новые треды" ("New threads")). На вкладке «Новые» показывать треды по дате создания, и после списка "ещё не увиденных" (определеямых по попаданию на экран целиком при скролле или при user input, как описано уже) тредов рисовать черту, писать «Просмотрено» и показывать список остальных тредов. На вкладке «Новые» показывать счётчик "ещё не увиденных" тредов ("+N" или просто "N").

На странице доски в BoardThreadMenu можно сделать кнопку обновления списка тредов (содержимое и значок вкладки "Новое", и т.д.).

Сохранять черновики текста комментариев и ответов в `localStorage`, и очищать их при истечении тредов.

В `VirtualScroller.itemState` — хранить не просто `showReplyForm`, но и её `content`, вместе с attachments и прочими полями формы.





Add floating "Add new comment/thread", "Go to top" buttons:

На мобильных: "< Доска" ("назад") — слева снизу, "^ наверх" — справа снизу. Кнопки сами — круглые, мб не большие, без текста.

На десктопах (с размера, когда видно sidebar слева): "< Доска" ("назад") — полоска слева, на пустом месте, темнеет по наведению мыши, наверху иконка-стрелка; "^ наверх" — полоска справа, на пустом месте, темнеет по наведению мыши, наверху иконка-стрелка.

Кнопка "Ответить", "Написать комментарий", "Создать тред": круглая кнопка-плюс. Иконка — плюс. Раскрывает форму отправки сообщения (выезжает снизу в `position: fixed`, добавляя padding bottom странице; после отправки сообщения — уезжает вниз).






При заходе на страницу: сортировать отслеживаемые треды в порядке обновления и обновлять их по порядку.

В мобильном меню показывать значок уведомлений ("красный"), если есть новые комментарии в отслеживаемых тредах.

В Application.didMount запускать обновляльщик отслеживаемых тредов: через интервал в 15 минут будет в секунду обновлять по одному треду, показывая спиннер в сайдбаре (и пересортировывать после каждого обновлённого треда). Писать время refreshedAt, addedAt, latestCommentDate (для измерения возможного рейтинга stale thread), newCommentsCount, newRepliesCount.

Помечать наиболее поздние прочитанные сообщения и треды:
* в virtual scroller по скроллу ручному (не программному), когда они полностью попали в экран.
* по любому user input-у (keydown, mousemove threshold, scroll, click, etc), если есть какие-то "не прочитанные" комментарии или треды в списке, и они полностью попали в экран.

При "прочтении" непрочитанных сообщений в треде (как описано выше) — обновлять UserData, что перерендерит счётчики уведомлений и пересортирует список отслеживаемых тредов.

Сортировать треды отслеживаемые сначала по тем, в которых replies (по количеству), потом те, в которых комментарии (по количеству), потом остальные.

Если в треде есть новые сообщения, то показывать рядом со счётчиком иконки сообщений их количество вида "+N": так пользователь может узнать, насколько много комментариев появилось в треде с того момента, как он в него заходил в прошлый раз.

Можно сделать обновления в thread tracker через service workers (не зависят от открытости/закрытости сайта).





Можно сделать preview комментария/темы перед отправкой.

Check <video/> border (focused).

Сохраняется ли фокус на видео, когда autoPlay меняется с false на true в slideshowMode.

Maybe add hotkeys for "Expand attachments" and "Start slideshow".

Toggle search on Ctrl/Cmd + F.

Expand attachments: max height === screen height - header/footer height.


Show the "bump limit" indicator in the "Watched threads" list for threads that have reached their "bump limit". Also show "Closed thread" indicator there.

Как-то помечать цветом (или полоской слева, или ещё как-то) own comments, own threads, replies to own comments.



В цитатах можно показывать link.content и service link icon вместо link.url, и для youtube video добавлять иконку youtube. Также можно к "Картинка" добавлять иконку картинки (или даже вставлять ту картинку, которая цитируется, в уменьшенном видео), а к "Видео" — иконку видео (или картинку preview в уменьшенном виде).

Также можно в цитатах зацензуренные слова делать не квадратами, а красным спойлером, как обычно. Но квадраты останутся, например, для автогенерации thread.subject.




Ссылку на доску в шапке сделать как "goBack()".

При ответе в тред сделать галку "Не отслеживать комментарии в этом треде".


Redo screenshots.




Может быть проставлять постам что-то типа commentQuoteText, чтобы не вычислять его каждый раз.

При нажатии на ссылки вида "Сообщение" (а также при нажатии на дате сообщения, или на цитате сообщения) — неанимированно скроллить на этот комментарий плюс top offset на высоту Header'а. При нажатии на ссылки вида "Сообщение" (а также при нажатии на дате сообщения, или на цитате сообщения) происходит добавление "якорей" в истории браузера — делать на этих ссылках `onClick` с `event.preventDefault()`, чтобы история не разбухала.

Мб делать какую-то кнопку "Вернуться" (со стрелкой в соответствующем направлении: вверх или вниз) после перехода к некоторому сообщению по ссылке на него (включая цитату).

Что, если цитируемое сообщение не загружено (например, если показываются сообщения с "самого позднего прочитанного") — в таких случаях сначала показывать предыдущие сообщения и делать им `parseContent()`, а уже потом крутить на них.

При заходе на сайт по ссылке на комментарий — прокручивать на этот комментарий.

Highlight the linked comment when navigating to comment URL (maybe add a border around it or something).

При переходе по ссылке comment URL или board URL: мотать список досок так, чтобы текущая доска там была где-нибудь ближе к верху на экране.

Implement comment "..." menu: Copy URL (only on Thread page), Report, Hide, etc.


If a thread is in bump limit show a waterline after the last bumping message (including the last one maybe) with a sailing ship icon and some text ("This thread has reached bump limit and will eventually disappear").






Throw `404` on `2ch` on `/catalog` if board is `ageRestricted` and no `usercode_auth` cookie is present.


Show age restricted warning modal (age restriction consent) when navigated to either `ageRestricted` board or a thread on an `ageRestricted` board. Set `ageRestrictionConsent={true}` cookie.

(`2ch.hk` sets `ageallow` cookie to `1` in this case)

Получая доступ ко взрослым разделам Двача вы осознаете и соглашаетесь со следующими пунктами:

•Содержимое этого сайта предназначено только для лиц, достигших совершеннолетия. Если вы несовершеннолетний, покиньте эту страницу.
•Сайт предлагается вам "как есть", без гарантий (явных или подразумевающихся). Нажав на "Я согласен", вы соглашаетесь с тем, что Двач не несет ответственности за любые неудобства, которые может понести за собой использование вами сайта, а также что вы понимаете, что опубликованное на сайте содержимое не является собственностью или созданием Двача, однако принадлежит и создается пользователями Двача.
•Существенным условием вашего присутствия на сайте в качестве пользователя является согласие с "Правилами" Двача, ссылка на которые представлена на главной странице. Пожалуйста, прочтите Правила внимательно, так как они важны.

Я согласен и подтверждаю, что мне есть 18 лет
Уйти отсюда



Можно починить каким-то образом доступ в "скрытые разделы" `2ch.hk` после оставления поста (перенаправлять cookies через CORS-proxy).



При догрузке сообщений ("автообновление треда") обновлять список `replies` у предыдущих постов (и обновлять счётчик у иконки ответов, перерендеривая пост целиком — если её не было, то будет она и счётчик "1").



Сделать "экспорт треда" в json с картинками в base64.



Добавить "скрытие" авторов ("Скрытое сообщение (автор {authorId})"), комментариев, тредов.

При скрытии комментария — перегенерировать автоматически сгенерированные цитаты для комментариев, цитирующих его.

"Скрытые сообщения" в постах называть как "Скрытое сообщение (причина)". Например, "(автор {authorId})".


На `2ch.hk` сохранять в UserData выбранную иконку (board-wide setting).



Load instagram posts through CORS proxy (if configured).


При показе цитаты на "Удалённый комментарий" делать его без ссылки и с `title="Deleted comment"`.

Обновление в `react-time-ago` можно вынести в `requestIdleCallback()`.




Сделать отключаемым список игнорируемых слов.

Сделать настраиваемым список игнорируемых слов в настройках (можно сделать галку: "расширяет список по умолчанию" или "заменяет список по умолчанию").




На странице доски можно добавить кнопку "Обсуждаемое" ("Active"), где показывать "топ" тредов (по "скорости" постинга в них). Такой API есть на `2ch.hk`.




Движок Двача не даёт просто так взять и запостить mp3 или m4a файл.
В случае с mp3 или wav, он просто возвращает ошибку "-11: Тип файла не поддерживается."
В случае с m4a, он конвертирует аудио в видео формата mp4 с нулевой шириной и высотой.
В принципе, клиент мог бы на лету конвертировать из wav/mp3 в m4a, и потом показывать ролики mp4 нулевой ширины в виде аудиоплеера, но выглядит как какой-то хак.
Хз, почему не сделано просто прикрепление mp4/wav.
Возможно, чтобы РосКомНадзор не блокировал за пиратскую музыку.
В принципе, запись с микрофона в формат m4a реализовать, наверное, как-то можно на клиенте.






ignore words: validate rules on save and on compile.



На `4chan.org`, если нажать на id постера, то будут подсвечиваться все его посты в треде. Это удобно. Можно сделать в настройках какой-нибудь функционал типа "Назначить прозвище и цвет автору с id = ...", при котором в `postAuthor` будет выводиться только это прозвище (без id, имени, емейла, роли, и т.п.), и в дополнение к этому background у этого прозвища может быть назначен каким-то цветом, выбираемым пользователем в виджете по кнопке "Назначить цвет". Эта фоновая заливка прозвища должна как-то отличаться от обычной фоновой заливки id автора, чтобы сразу "на подходе" уже было видно, не смотря прямо на сообщение.



При автозамене кавычек на парные (`«»`) они могут ставиться неправильно, когда весь текст в кавычках разделён другими блоками. Например: `"Цитата <strong>блок</strong>" "Вторая цитата"` -> `"Цитата <strong>блок</strong>« »Вторая цитата"`. При подобной автозамене кавычек можно проставлять флаг, если попалась первая непарная кавычка, и в случае проставления такого флага дальше уже не автозаменять кавычки.

Можно добавить IntersectionObserver в компонент Picture (lazy load): загружать картинки только тогда, когда они будут видны через высоту экрана, например (Page Down).


Мб как-то отличать страницу доски и страницу треда (сейчас не понятно, где находится пользователь, на мобильных).

Можно сделать страницу с хоткеями, где сделать хоткеи на Slideshow Flow Mode и Expand Attachments и Toggle Favorite Thread.


--------------------------------------------------------------------------------------------

Можно создать issue в `arisuchan` и `lainchan`, `4chan` и `8ch`. Также можно создать треды на их чанах.
https://github.com/arisu-dev/arisuchan
https://github.com/lainchan/lainchan

Можно добавить `tumba.ch` (у них свой движок по типу `4chan`).

Можно добавить `wizchan.org` (`4chan` api).
https://wizchan.org/

Можно отображать время изменения комментария (`updatedAt` в `lynxchan` API response).

Alternatively, hypothetically, someone could change `commentsShownBeforeLatestReadCount` from `0` to `2`, and then, when a user navigates to an already visited thread page, scroll down so that the earliest unread comment (or "no new comments" message) is positioned at about 25% of page height from the top. Such scroll position adjustment would also have to be "dynamic" in a way that if some embedded media (like a YouTube video) is loaded and "expanded" in one of the "already read" comments, and the user hasn't scrolled down yet, then the scroll position should automatically adjust itself in order to compensate for the changed "already read" comments height.

При истечении треда (если он не найден в каталоге, или выдаётся 404 по клику на него) — по нажатию на него в списке отслеживаемых тредов направлять на "архив". Например, на дваче это "https://2ch.hk/pr/arch/2020-07-29/res/1634080.html#1634080" (тред — https://2ch.hk/pr/res/1634080.html#1634080, `"date": "16/03/20 Пнд 00:37:16",`, `"timestamp": 1584308236`) (при этом не известно, как вычисляется дата архивирования треда: например, пользователь зашёл через неделю — и как программа узнает, какую дату нужно подставлять в URL архива), а на форчане тред просто помечается как `archived: 1`. Иногда тред не обязательно в архиве — может быть просто удалён модератором, например.

Если бы чаны предоставляли API для топа тредов по всему чану вообще, то можно было бы сделать такой раздел меню. Иконка — "огонь".

"Комментарии из другого треда": можно после показа страницы как-то подгружать эти "другие треды", и автогенерировать им цитаты, как-то отмечая, что это цитата из другого треда.

Можно добавить анимацию (как в Твиттере) иконке "Добавить тред в избранное".

<!-- (caching won't work when auto-scrolling right to "new unread comments") Cache board and thread data: при заходе на доску показывать старый каталог (при заходе в тред показывать старые сообщения), и крутилку показывать, что обновляется. (можно где-нибудь в Header'е показывать). -->

Парсинг треда можно распараллелить: можно парсить его в `requestIdleCallback()`, или можно парсить в Web Worker-е (отдельный тред). Время это не сократит, но отзывчивость интерфейса может увеличить за счёт непросадок FPS, хотя кто там что делает во время загрузки треда — думаю, разницы не будет.

Можно сделать "экспорт треда" в PDF (наверное, предпочтительнее будет PDF с expand attachments = true). Как тогда в PDF в файле экспорта будут представлены вложения-файлы (музыка, документы, архивы).

Можно сделать настройку "Левша" ("Изменяет порядок пунктов мобильного меню на обратный.").

Уведомления: дизайн — как в контакте ("Показать все" внизу). Можно использовать "системные уведомления" обозревателя. Разрешение на них можно запрашивать при первом постинге. Текст можно делать кастомный, или кастомное окошко в целом. Звук какой-нибудь можно прикрутить (мб с возможностью кастомизации URL'а этого звука в рамках какой-нибудь темы). Сделать настройку как в контакте: "Получать уведомления обозревателя" с description.

<!-- Уведомления хранить в UserData. -->

Мб снизить обратно поинты аттачментам. А мб и не снижать.

<!-- В списке отслеживаемых тредов показывать "[крутилка] Обновление" шрифтом 16px серым цветом наверху списка, когда он обновляется. -->

<!-- Список отслеживаемых тредов делить на две части: треды, отслеживаемые вручную (наверху), и треды, добавленные в отслеживаемые по ответу в них (внизу). -->

<!-- Во вкладке "Уведомления" — показывать также сообщения вида "Ваш комментарий набрал N лайков/дизлайков", если новое количество лайков/дизлайков отличается от предыдущего количества лайков/дизлайков "сильно": 0 -> >= 1, ... -->

Мб вынести кнопки меню треда/доски в основной хедер на десктопе (и сделать разделитель диагональный справа).

<!-- В режиме preview (mode === 'board') скрывать остальные attachments, и показывать кнопку "Show more attachments" ("Показать все вложения"). -->

<!-- Сделать страницу "/feed", где помещать сверху самые новые комментарии в отслеживаемых тредах, и на иконке "Feed" можно показывать красную точку под иконкой (как в инстаграме), если что-то новое появилось. ("самые новые" — в порядке даты получения этого "нового" в рамках отслеживания тредов, и показывать, начиная с после "последнего прочитанного") -->

<!-- Можно сделать раздел меню "Профиль", где будут разделы "Мои треды" и "Мои сообщения" с индикацией статуса (удалено или ещё не удалено): так могут сохраняться посты и треды, даже если сами треды уже того. Вход в настройки можно сделать через "Профиль", как в Инстаграме. -->

<!-- Ограничить ownComments и ownThreads длиной. trackedThreads — тоже. -->

<!-- Мб количество ответов не показывать в "Отслеживаемых тредах", а показывать их отдельно в "Уведомлениях". Сбрасывать статус нового в "Отслеживаемых тредах" и "Уведомлениях" при прочтении комментариев (при очередном обновлении, например; или если прочёл комментарии в этой же вкладке). -->

В слайдшоу: возможно, не показывать video preview, если размер preview очень мал, а сразу показывать HTML <video/>.

Maybe add loading indicator stripe on top instead of the default spinner + loading indicator stripe under board name when clicking it in boards list + loading indicator stripe under thread preview when clicking it in threads list (but then such loading stripe may be not visible to a user if a post is not fully visible on screen).

"Удалённое сообщение" можно перечёркивать, или делать серым, или писать "В ответ на удалённое сообщение:" ("In reply to a deleted comment") (серым). "Сообщение(я)(й)" можно заменить везде на "Комментарий(я)(й)". То же самое: заменить Message(s) на Comment(s).

<!-- Можно сделать страницу "Лента" (/feed) как в социальных сетях, на которой будут перечислены "отслеживаемые" треды, упорядоченные по "latest bump date". -->

При нажатии на "Показать все" (отслеживаемые треды) можно показывать и фокусировать сверху какой-нибудь Search Bar, в котором искать можно так: разбивать инпут по пробелам и прочей пунктуации (",", ".", "-", "—", ":", ";", "!", "?", "(", ")", "/"), и так же разбивать "boardId threadTitle", и далее искать пересечение этих индексов (причём последний "токен" можно матчить по подстроке).

Add a notification when a watched (or own) thread expires. Add a notification when watched (or own) thread reaches "bump limit".

Backup YouTube video api with oEmbed through CORS proxy (if configured).

В "Слайдшоу" можно добавить "Поиск в iqdb":
https://iqdb.org/?url=http://i.4cdn.org/a/1554643360980s.jpg

// При открытии картинки на мобильных: она может загружаться через "крутилку", и, соответственно, будет затемнение миниатюры (с показом "крутилки"), и если проигрывается анимация "scaleOpenCloseTransition", то затемнение пропадёт сразу на увеличиваемой миниатюре.

// Мб показывать "latest replies" у тредов на странице каталога. 4chan — предоставляет такое в catalog.json. На 2ch — теоретически можно как-то запрашивать отдельно https://2ch.hk/b/catalog.json, и одновременно https://2ch.hk/b/index.json, и заполнять "latest replies" на первой "странице" каталога с возможностью догрузки остальных "страниц" (https://2ch.hk/b/1.json, и т.д.). При этом будет рассинхронизация, потому что "страницы" постоянно обновляются, т.к. пишутся новые посты, и если, например, запрошена первая страница, то вторая страница уже будет не совсем "второй", т.к. треды уже пересортируются после появления в них новых комментариев. У Lynxchan — принцип мог бы быть тем же самым (https://kohlchan.net/b/1.json); это также могло бы решить вопрос "упрощённых" версий ОП-постов (конкретно, их attachment-ов), которые lynxchan выдаёт в catalog.json. Например, если пользователь зашёл на доску, и листает её, и продолжает листать (докрутил докуда-то), то догружать "страницы" по кругу (1, 2, ...) в некоторый кеш, из которого уже потом заполнять "latest replies" у тредов на странице каталога. Если какой-то тред не попал в кеш после прохода, то мб запрашивать его напрямую через `getThread()`. Пока грузятся "latest replies", можно не показывать заглушки на их месте, потому что в треде может и не быть ответов.

Можно сделать какой-нибудь архиватор треда. Картинки и видео можно скачивать в виде `Blob`'ов через `fetch()`. Далее эти `Blob`'ы можно упаковывать вместе с `index.html`, в котором может быть записан JSON постов треда, и через javascript этот JSON может отображаться в разметку `<body/>`. Далее, `index.html`, копия JSON'а и `Blob`'ы, видимо, могут быть записаны в ZIP-архив (тоже `Blob`), который уже потом может быть скачан из браузера в виде файла.

```js
const response = await fetch("url")
response.blob()
```

```js
var zip = new JSZip();

zip.file("Hello.txt", "Hello World\n");

var img = zip.folder("images");
img.file("smile.gif", imgData, {base64: true});

zip.generateAsync({type:"blob"}).then(function(content) {
    // see FileSaver.js
    saveAs(content, "example.zip");
});

/*
Results in a zip containing
Hello.txt
images/
    smile.gif
*/
```

Могла бы быть какая-то проверка CORS-прокси при открытии страницы с выводом сообщения в случае неработы CORS-прокси.














































4chan post
==========

```
https://www.google.com/recaptcha/api2/reload?k=6Ldp2bsSAAAAAAJ5uyx_lx34lJeEpTLVkP5k04qc
https://www.google.com/recaptcha/api2/userverify?k=6Ldp2bsSAAAAAAJ5uyx_lx34lJeEpTLVkP5k04qc

https://sys.4chan.org/b/post

FormData

Check `image_limit` from Board's info from `boards.json`.
Check `max_comment_chars` from Board's info from `boards.json`.
Check `cooldowns.replies` from Board's info from `boards.json`.

withCredentials = true.

if (Main.board == 'q') {
  this.baseDelay = 60
  this.fileDelay = 300
  this.sageDelay = 600
}
else {
  this.baseDelay = 30
  this.fileDelay = 30
  this.sageDelay = 60
}

this.captchaDelay = 240


sel = UA.getSelection()
if (sel) {
  q += '>' + sel.trim().replace(/[\r\n]+/g, '\n>') + '\n'
}

form = postForm.parentNode.cloneNode(false);
form.setAttribute('name', 'qrPost');
form.innerHTML =
  '<input type="hidden" value="'
  + $.byName('MAX_FILE_SIZE')[0].value + '" name="MAX_FILE_SIZE">'
  + '<input type="hidden" value="regist" name="mode">'
  + '<input id="qrResto" type="hidden" value="' + tid + '" name="resto">';

https://github.com/4chan/4chan-JS/blob/8714d5fe9c138bdb0587c860a90a1289ffda65e3/extension.js

id="captchaFormPart"

row.innerHTML = '<img id="qrCaptcha" title="Reload" width="300" height="57" src="'
  + $.id('recaptcha_image').firstChild.src + '" alt="reCAPTCHA challenge image">'
  + '<input id="qrCapField" name="recaptcha_response_field" '
  + 'placeholder="reCAPTCHA Challenge (Required)" '
  + 'type="text" autocomplete="off" autocorrect="off" autocapitalize="off">'
  + '<input id="qrChallenge" name="recaptcha_challenge_field" type="hidden" value="'
  + $.id('recaptcha_challenge_field').value + '">';

Maybe check banned status on error:

QR.banXhr.open('GET', '//api.4chan.org/banned?' + Date.now())
if (status == 403)

// byteLength = encodeURIComponent(comment).split(/%..|./).length - 1;

MAX_FILE_SIZE: 2097152 // Board's `max_filesize` from `https://a.4cdn.org/boards.json`.
mode: regist // Whatever.
resto: 792190180 // Thread ID.
email: // (optional) Author email.
com: Like 2ch.hk/b/ ? // Comment text.
upfile: (binary) // (optional) An attachment (a picture or a webm video).
g-recaptcha-response: 03AF6jDqXUEXD6OJXDFm9i8hA-eQxsVWxSXiPDSTvUklz1oaVKZdl7-TR-SIXyElx1zypXqsJWkVI9WH3YU8VytGzV1IoV0Psxwwxo8Q9xw7j17-vpJ8s5WZ-oPzoS2CLOaQTbEe01ay0g8CdGsk9KqA8WsH40x3ZawoEZYWeuJlF53EHny_sWBCcVgps8QI-a1OUCI-2yuf_l-5NWXiY_AvdNdpjaZzWvEDTDmGeeiooOhbotYA-IJA6b7WeLalsNWa-UsYxOuOOdrizWHFjXR0Mk2ChpHca7VeyiuaBYZAwVXGc8YZVz5bUvGZ-8ruMRuE9Le208HjFG // Google ReCaptcha "response".

Access-Control-Request-Method: POST
Origin: http://boards.4chan.org
Referer: http://boards.4chan.org/
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/71.0.3578.98 Safari/537.36

Response:

<!DOCTYPE html><head><meta http-equiv="refresh" content="1;URL=http://boards.4chan.org/bant/thread/7466194#p7466464"><link rel="shortcut icon" href="//s.4cdn.org/image/favicon.ico"><title>Post successful!</title><link rel="stylesheet" title="switch" href="//s.4cdn.org/css/yotsubanew.685.css"></head><body style="margin-top: 20%; text-align: center;"><h1 style="font-size:36pt;">Post successful!</h1><!-- thread:7466194,no:7466464 --></body></html>

Check `<span id="errmsg" style="color: red;">Error: ...</span>`.

    if (this.status == 200) {
      if (resp = this.responseText.match(/"errmsg"[^>]*>(.*?)<\/span/)) {
        QR.reloadCaptcha();
        QR.showPostError(resp[1]);
        return;
      }
    }

Not exists:

<hr class="abovePostForm"><table style="text-align: center; width: 100%; height: 300px;"><tr valign="middle"><td align="center" style="font-size: x-large; font-weight: bold;"><span id="errmsg" style="color: red;">Error: Specified thread does not exist.</span><br><br>[<a href=http://boards.4chan.org/b/>Return</a>]</td></tr></table><br><br><hr size=1><div id="absbot" class="absBotText">

Spam:

<hr class="abovePostForm"><table style="text-align: center; width: 100%; height: 300px;"><tr valign="middle"><td align="center" style="font-size: x-large; font-weight: bold;"><span id="errmsg" style="color: red;">Error: Our system thinks your post is spam. Please reformat and try again.</span><br><br>[<a href=http://boards.4chan.org/r9k/>Return</a>]</td></tr></table><br><br><hr size=1><div id="absbot" class="absBotText">

access-control-allow-credentials: true
access-control-allow-headers: If-Modified-Since
access-control-allow-methods: GET, OPTIONS
access-control-allow-origin: http://boards.4chan.org

if (ids = this.responseText.match(/<!-- thread:([0-9]+),no:([0-9]+) -->/)) {
  tid = ids[1];
  pid = ids[2];

  if (Main.tid) {
    QR.lastReplyId = +pid;
    Parser.trackedReplies['>>' + pid] = 1;
    Parser.saveTrackedReplies(tid, Parser.trackedReplies);
  }
  else {
    tracked = Parser.getTrackedReplies(tid) || {};
    tracked['>>' + pid] = 1;
    Parser.saveTrackedReplies(tid, tracked);
  }
}
```